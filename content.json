{"meta":{"title":"Hexo","subtitle":"�չ�һ�䣬�����ƾ�","description":null,"author":"����","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-04T06:13:12.458Z","updated":"2020-03-03T04:23:20.680Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"听风的个人博客","date":"2020-03-04T05:05:18.007Z","updated":"2020-03-04T05:05:18.007Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这个人比较懒。。。"},{"title":"书单","date":"2020-03-06T07:48:36.869Z","updated":"2020-03-03T04:23:20.696Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-03T04:23:20.701Z","updated":"2020-03-03T04:23:20.701Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-03T04:23:20.705Z","updated":"2020-03-03T04:23:20.705Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-04T05:09:30.639Z","updated":"2020-03-03T04:23:20.710Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-03T04:23:20.714Z","updated":"2020-03-03T04:23:20.714Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"作业管理系统实现——springboot+jsp","date":"2020-06-19T01:12:15.385Z","updated":"2020-06-19T01:14:33.100Z","comments":true,"path":"2020/06/19/作业管理系统实现——springboot+jsp/","link":"","permalink":"http://yoursite.com/2020/06/19/作业管理系统实现——springboot+jsp/","excerpt":"","text":"作业管理系统 简介：&nbsp; &nbsp;技术：&nbsp; &nbsp;&nbsp; &nbsp;jsp + springboot + layui + mybatis + docker + restful api&nbsp; &nbsp;功能：&nbsp; &nbsp;&nbsp; &nbsp;老师：登录，注册，添加学生、作业（面向自己的学生），查看自己的学生、自己布置的作业以及学生作业的完成情况，删除学生、作业，更改作业信息，退出登录&nbsp; &nbsp;&nbsp; &nbsp;学生：登录，注册查看作业、提交作业（可重复提交），退出登录 &nbsp; &nbsp;github地址: 项目传送门 一、数据库设计 数据库一共有五张表,设计均满足第三范式要求: student(sid)&nbsp; &nbsp; teacher(tid)&nbsp;&nbsp; homework(hid)&nbsp; &nbsp; student_homework(sid, hid) teach(sid, tid) 以下是数据库关系模式图 二、用例设计 用例图 三、流程图设计1. 学生流程 2. 教师流程 四、详细设计1. 结构总览 项目总共两大模块: core 和 webcore：&nbsp; 主要包含model和util，model存放的是实体类，util存放工具类，这里存放了一个SpringContextUtil，用来获取Context创建beanweb：&nbsp; java目录下主要包含一些源代码，config、controller、dao、service，分别存放配置类、路由映射、mybatis访问接口、服务.&nbsp; resources下包含springboot的配置文件，mybatis-generator的配置文件，mybatis的mapper文件&nbsp; web-app下包含jsp页面和web.xml 2. 登录模块 采用了前端cookie保持登录状态，当再次打开登录页面时，会进行登录状态的判断，若已登录且未退出，则会自动进行登录，登录成功与登出成功的时候则会改变cookie中的登录状态。 添加了拦截器设置，用来检验登录状态，未登录时不能访问只有登录后才能访问的页面，通过WebConfig配置学生和老师相关操作的拦截器。 记住密码功能，使用cookie记住最近一次登录成功的用户名+密码，不小心退出后可以直接登录。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//login.jsp进行登录判断，通过cookie获取登录状态和已登录的账号密码&lt;% request.setCharacterEncoding(\"utf-8\"); //防止中文乱码 Cookie[] cookies = request.getCookies(); boolean studentLogged = false; boolean teacherLogged = false; String username = \"\"; String password = \"\"; if(cookies != null)&#123; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/student/studentHome\"); &#125; else if (\"teacher_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/teacher/teacherHome\"); &#125; break; &#125; &#125; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_false\".equals(loginStatus)) &#123; studentLogged = true; &#125; else if (\"teacher_false\".equals(loginStatus)) &#123; teacherLogged = true; &#125; break; &#125; &#125; if(teacherLogged || studentLogged)&#123; //输入框显示账号密码 for(Cookie c : cookies)&#123; if(\"username\".equals(c.getName()))&#123; username = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; if(\"password\".equals(c.getName()))&#123; password = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; &#125; &#125; &#125;%&gt; 1234567//login.jsp 显示密码&lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; studentLogged)&#123; %&gt;&lt;script&gt; document.getElementById(\"s_username\").value = &lt;%=username%&gt;; document.getElementById(\"s_password\").value = &lt;%=password%&gt;;&lt;/script&gt;&lt;%&#125;%&gt; 123456789101112131415161718//StudentInterceptor拦截示例@Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; Cookie[] cookies = request.getCookies(); String loginStatus = \"\"; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; return true; &#125; break; &#125; &#125; response.sendRedirect(\"/login\"); return false; &#125; 3. service设计 抽象出StudentService和TeacherService两个接口，在impl包下进行实现，好处是有新的实现时上层不用做修改。 使用@Transactional注解TeacherServiceImpl中的addHomework, removeStudent, deleteHomework三个方法，因为方法当中的多个sql必须绑定执行才符合逻辑，也可以使用之前学到的AOP代理实现，就是稍微麻烦点。 4. Restful api设计 url method description / get 跳转至登录界面 /login get 跳转至登录界面 /logout get 退出登录 /studentLogin post 学生登录 /teacherLogin post 教师登录 /studentRegister get 跳转至学生注册界面 /studentRegister post 学生注册 /teacherRegister get 跳转至教师注册界面 /teacherRegister post 教师注册 /register-success get 注册成功界面 /studentHome get 学生主页（自己的作业列表） /homework get 查看作业 /homework post 提交/更新作业 /new-homework get 跳转至添加作业界面 /new-homework post 添加作业 /homework post 修改作业 /homework get 跳转至修改作业界面 /homework delete 删除作业 /new-student get 跳转至给自己班级添加学生的界面 /new-student post 添加1个或多个学生到自己班级 /student delete 将学生移除班级 /teacherHome get 教师主页（该教师班级学生列表） /teacherHomework get 作业列表(仅含该教师布置) /studentHomework get 某一作业的所有学生的完成情况 5. 其他设计 js表单验证，登录、注册、提交作业以及布置作业时的验证。 表单提交错误相关提示，密码错误、用户表不存在等提示信息。 dao层与mapper是通过myabtis-generator插件生成的。 重复提交时会自动显示之前提交内容，教师修改作业也是一样的 这里举两个例子： 密码必须6-12位，不含空格密码错误： 五、界面展示1.登录注册1.1学生登录（登陆成功会用cookie记住账户密码） 1.2 教师登录(这里使用cookie记住了账户密码) 1.3 学生注册 1.4 教师注册 1.3 注册成功： 2.学生部分2.1 学生主页 2.2 提交作业（可重复提交，之前有提交内容时会自动显示） 3. 教师部分3.1 主页（自己教的学生）可以对自己教的学生进行添加和移除 3.2 从不属于自己学生的列表添加自己的学生 3.3 自己发布的作业列表，可以添加新作业、查看、删除某一作业 3.4 修改作业内容（自动显示之前的内容） 3.5 发布新的作业3.6 查看某一作业自己所有学生的完成情况六、Docker部署(多模块Maven项目)1. docker 部署springboot镜像1.1环境准备（以下操作在springboot的web模块进行）123456789//由于springboot对jsp不友好，需要将maven-plugin改为1.4.2.RELEASE版本 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.2.RELEASE&lt;/version&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt; &lt;/plugin&gt; 1234567891011121314151617181920212223242526272829//一些docker打包的插件 &lt;plugin&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.13&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;default&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;build&lt;/goal&gt; &lt;goal&gt;push&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;repository&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/repository&gt; &lt;tag&gt;$&#123;project.version&#125;&lt;/tag&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;$&#123;project.build.finalName&#125;.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; 1.2 Dockerfile编写123456789101112FROM openjdk:8-jreENTRYPOINT [\"java\", \"-jar\", \"/usr/share/myservice/app.jar\"]VOLUME /usr/share/myserviceRUN mkdir -p /usr/share/myserviceWORKDIR /usr/share/myserviceARG JAR_FILEADD $&#123;JAR_FILE&#125; /usr/share/myservice/app.jar 1.3开始制作12345678//进入父模块，执行如下命令，打包父工程里面的依赖mvn clean install package -Dmaven.test.skip//进入入口模块(一般是web模块，这儿是springboot的web模块)执行如下命令，入口镜像打包和生成镜像mvn package dockerfile:build -Dmaven.test.skip//使用docker images查看生成镜像docker images 1.4 运行测试12//本地运行测试docker run --name service -p 8088:8083 springboot/web:1.0-SNAPSHOT 截图（Docker Desktop） 2. docker-compose 部署springboot+mysql上面的是没有整合mysql的，依赖本地mysql，现在给springboot项目整合docker的mysql2.1相关配置12345678910111213141516171819202122232425262728293031323334353637383940//在根目录下新建docker-compose.yml,配置springboot和mysql的相关配置version: '3.8'services: webapp: build: context: ./web dockerfile: Dockerfile restart: always ports: - 8088:8083 volumes: - /vol/development depends_on: - mysql links: - mysql:mysql mysql: container_name: mysql-container build: context: ./mysql dockerfile: Dockerfile restart: always ports: - 33068:3306 environment: MYSQL_DATABASE: class MYSQL_ROOT_HOST: '%' MYSQL_ROOT_PASSWORD: 123456 command: [ 'mysqld', '--innodb-buffer-pool-size=20M', '--character-set-server=utf8', '--collation-server=utf8_general_ci', '--default-time-zone=+8:00', '--lower-case-table-names=1', '--default-authentication-plugin=mysql_native_password' ] 2.2 mysql目录下有两个文件：calss.sql和Dockerfile1234//DockerfileFROM mysql:8.0.20//将clas.sql添加到初始化执行的文件夹下，这样启动时就会自动执行ADD ./class.sql /docker-entrypoint-initdb.d/class.sql 2.3 web目录下的 Dockerfile（和之前差不多）12345678910//DockerfileFROM openjdk:8-jreENTRYPOINT [\"java\", \"-jar\", \"/usr/share/myservice/app.jar\"]VOLUME /usr/share/myserviceRUN mkdir -p /usr/share/myserviceWORKDIR /usr/share/myservice//这里在我的机器之前的JAR_FILE报错，换了这个ADD /target/web.jar /usr/share/myservice/app.jar 2.4 运行docker-compose命令12//执行该命令，制作启动镜像docker-compose up 然后就可以成功制作并启动了（DockerDesktop）： 注：以上两种方式运行时都要将springboot中mysql配置中url中的ip换成自己电脑的ipv4地址。七、总结 使用layui如果想通过ajax提交form一定要在ajax提交后写上：return false;否则表单会提交两遍！ springboot对jsp的支持较差，要添加的东西比较多，我在我的pom.xml中注释了出来，遇到问题的童鞋也可以参考一下。 mybatis-generator插件真的好用，使用也比较简单，感兴趣的小伙伴可以学一下！ 关于mybatis，配置mapper和dao层时要求:在mapper文件中namespace等于对应接口的全限定名；接口中的方法名和mapper文件中的statement(,…标签)的id属性值一致;接口中的方法输入值参数和mapper文件中statement的parameterType指定的类型一致。接口中的方法的返回值类型和mapper文件中statement的resultType指定的类型一致。 docker访问外部时一定要注意将localhost之类的换成本地的ipv4地址！这里需要将springboot配置中的localhost更换成你的ipv4地址。","categories":[],"tags":[]},{"title":"Java EE - 02 做一个作业管理系统（jsp+servlet+layui）","slug":"JAVAEE-02 做一个作业管理系统—jsp+servlet+layui","date":"2020-03-17T02:41:00.529Z","updated":"2020-03-18T16:25:16.614Z","comments":true,"path":"2020/03/17/JAVAEE-02 做一个作业管理系统—jsp+servlet+layui/","link":"","permalink":"http://yoursite.com/2020/03/17/JAVAEE-02 做一个作业管理系统—jsp+servlet+layui/","excerpt":"","text":"JAVAEE-02 做一个作业管理系统（jsp+servlet+layui） 简介github地址： 传送门技术实现：servlet + jsp + layui + mysql ， 之前学了下layui，所以顺便就用上了，还是蛮好用的哈哈。主要功能：&nbsp; &nbsp;老师：登录，注册，添加自己的新学生、作业（只能面向自己的学生，也可以是部分学生），查看自己的学生、自己布置的作业以及学生作业的完成情况，删除学生、作业，更改学生信息，更改作业信息，登出&nbsp; &nbsp;学生：登录，查看作业、提交作业，登出 一、数据库设计 数据库一共有五张表,设计均满足第三范式要求: student(sid)&nbsp; &nbsp; teacher(tid)&nbsp;&nbsp; homework(hid)&nbsp; &nbsp; student_homework(sid, hid) teach(sid, tid) 数据库连接类采用了单例模式，在第三部分代码设计会讲到。 以下是数据库关系模式图 二、业务流程 学生流程图 老师的流程图 三、代码设计 采用了前端cookie保持登录状态，当再次打开登录页面时，会进行登录状态的判断，若已登录且未退出，则会自动进行登录，登录成功与登出成功的时候则会改变cookie中的登录状态。 添加了拦截器设置，用来检验登录状态，未登录时不能访问只有登录后才能访问的页面，除了index.jsp(欢迎页面，在这个页面里我直接跳转到了登录页面)、login.jsp、register.jsp registerSuccess.jsp、/studentLogin、/teacherLogin(需要登录验证的几个)页面外，属于老师的设置了拦截器TeacherLoginFliter，属于学生的设置了StudentLoginFilter。代码比较多，我在这贴一些主要的代码就行，剩下的我就不一一赘述，大家可以在我的的github去看&nbsp;&nbsp;仓库地址下面是StudentLoginFilter，TeacherLoginFilter也是类似的，在这就不贴了1234567891011121314151617181920212223242526272829303132public class StudentLoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(\"utf-8\"); //防止中文乱码 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; Cookie[] cookies = request.getCookies(); String loginStatus = \"\"; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; break; &#125; &#125; response.sendRedirect(\"login.jsp\"); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;StudentLoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kle.code.filter.StudentLoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 配置多个映射，哪些请求执行过滤器 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;StudentLoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/student/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;TeacherLoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kle.code.filter.TeacherLoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;TeacherLoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/teacher/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; login.jsp进行登录判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;% request.setCharacterEncoding(\"utf-8\"); //防止中文乱码 Cookie[] cookies = request.getCookies(); boolean studentLogged = false; boolean teacherLogged = false; String username = \"\"; String password = \"\"; if(cookies != null)&#123; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/student/studentHome\"); &#125; else if (\"teacher_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/teacher/teacherHome\"); &#125; break; &#125; &#125; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_false\".equals(loginStatus)) &#123; studentLogged = true; &#125; else if (\"teacher_false\".equals(loginStatus)) &#123; teacherLogged = true; &#125; break; &#125; &#125; if(teacherLogged || studentLogged)&#123; //输入框显示账号密码 for(Cookie c : cookies)&#123; if(\"username\".equals(c.getName()))&#123; username = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; if(\"password\".equals(c.getName()))&#123; password = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; &#125; &#125; &#125;%&gt;//刚开始显示的是学生登录页面&lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; studentLogged)&#123; %&gt;&lt;script&gt; document.getElementById(\"s_username\").value = &lt;%=username%&gt;; document.getElementById(\"s_password\").value = &lt;%=password%&gt;;&lt;/script&gt;&lt;%&#125;%&gt;&lt;/body&gt;&lt;script src=\"static/layui/layui.all.js\"&gt;&lt;/script&gt;&lt;script&gt; layui.use('element', function()&#123; var element = layui.element; //学生、老师登录页面切换监听 element.on('tab(demo)', function(data)&#123; //切换到学生页面 if(data.index === 0)&#123; &lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; studentLogged)&#123; %&gt; document.getElementById(\"s_username\").value = &lt;%=username%&gt;; document.getElementById(\"s_password\").value = &lt;%=password%&gt;; &lt;%&#125;%&gt; &#125;else &#123; //切换到老师页面 &lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; teacherLogged)&#123; %&gt; document.getElementById(\"t_username\").value = &lt;%=username%&gt;; document.getElementById(\"t_password\").value = &lt;%=password%&gt;; &lt;%&#125;%&gt; &#125; &lt;%&#125;%&gt; &#125;); &#125;);&lt;/script&gt; 数据库连接类 采用单例模式实现数据库连接资源获取类，在这我是用的是静态内部类的方式，利用了jvm的加载机制，当然也可以用DCL的方式实现，这两种都是比较推荐的实现方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class DbUtil &#123; private String url = \"jdbc:mysql://127.0.0.1:3306/class\"; private String allUrl = url + \"?user=kle&amp;password=yqyforever\"; public Connection getConnection()&#123; Connection conn = null; try &#123; String driverName = \"com.mysql.cj.jdbc.Driver\"; Class.forName(driverName); conn = DriverManager.getConnection(allUrl); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; /** * 关闭数据库连接 * @param rs * @param conn * @param stat */ public void close(Connection conn,Statement stat, ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; rs = null; &#125; &#125; if(stat != null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; stat = null; &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; conn = null; &#125; &#125; &#125; /** * 关闭数据库连接 * @param conn * @param stat */ public void close(Connection conn,Statement stat)&#123; if(stat != null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; stat = null; &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; conn = null; &#125; &#125; &#125; //静态内部类-单例模式 获取数据库资源连接类 private static class SingleHolder&#123; private static DbUtil INSTANCE = new DbUtil(); &#125; public static DbUtil getInstance()&#123; return SingleHolder.INSTANCE; &#125;&#125; DbUtil的使用 1234567891011121314151617181920212223242526public List&lt;Homework&gt; getHomeworkOfTeacher(String tid) &#123; String sqlString = \"SELECT * FROM homework WHERE tid=\" + tid; List&lt;Homework&gt; list = new ArrayList&lt;&gt;(); //获取连接 Connection connection = DbUtil.getInstance().getConnection(); ResultSet resultSet = null; try&#123; Statement statement = connection.createStatement(); resultSet = statement.executeQuery(sqlString); while (resultSet.next())&#123; Homework h = new Homework(); h.setHid(resultSet.getInt(\"hid\")); h.setTitle(resultSet.getString(\"title\")); h.setContent(resultSet.getString(\"content\")); h.setCreateTime(resultSet.getTimestamp(\"create_time\")); h.setUpdateTime(resultSet.getTimestamp(\"update_time\")); list.add(h); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭连接 DbUtil.getInstance().close(resultSet); &#125; return list; &#125; 四、页面展示注册、登录老师：学生： 五、总结心得1 . jar包的添加 不使用构建工具，这里以我使用的阿里的fastjson为例： ①File-&gt;Project Structure-&gt;Modules-&gt;Dependencies，添加jar包 ②Artifacts, 右键点击WEB-INF，创建lib文件夹，这儿有个注意的点：创建完成后在IDEA里是看不到这个文件夹的，只有在out文件夹下才能找到，所以没有找到的画不用太担心，属于正常现象 ③在右边项目里找到要添加的模块，右键点击Put into /WEB-INF/lib ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312230431469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDQ2ODUy,size_16,color_FFFFFF,t_70) ④最后点击ok就大功告成了 2 . WEB-INF属于安全目录，其下的文件是不能直接通过地址栏访问的 以下是几种访问WEB-INF下文件的方式 方法一:本来WEB-INF中的jsp就是无法通过地址栏访问的，所以安全。如果说你要访问这个文件夹中的jsp文件需要在项目的web.xml文件中去配置servlet格式差不多的配置就ok了方法二 &lt;jsp:forward page = “/WEB-INF/jsp/test/test.jsp” /&gt;方法三 request.getRequestDispatcher(“/WEB-INF/a.jsp”).forward(request, response); 3 . 关于数据库的单例模式我采用的是静态内部类，利用了jvm的类加载机制，当然推荐的还有DCL实现，当然还有其他的实现方式，不过大都有点缺陷，不是特别推荐使用。使用单例模式的原因：数据库链接用单例模式的原因：1，单例只保留一个对象，可以减少系统资源开销。2，提高创建速度，每次都获取已经存在的对象因此提高创建速度全局共享对象。3，单例在系统中只存在一个对象实例，因此任何地方使用此对象都是一个对象避免多实例创建使用时产生的逻辑错误。 这儿给大家推荐一篇博客，讲了单例模式的各种实现方式以及优缺点，大家可以看一下，讲的还是挺拔不错的，比较简洁单例模式实现博客链接静态内部类前面写过了，这儿说一下DCL，写的时候一定要在INSTANCE前加上volatile,避免jvm编译器的指令重排会导致并发问题 1234567891011121314public class Singleton &#123; private static volatile Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 4 .关于jsp接收到servlet返回数据的中文乱码 对请求以及响应进行编码设置即可12req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); 5 .Servlet向前端返回json等数据 123456String jsonString = \"[]\"; //获取response的Writer对象，用来写入返回数据 PrintWriter out = resp.getWriter(); out.write(jsonString); out.flush(); out.close(); 6 .之前在我的电脑发现了一个现象，我的电脑似乎不用导入mysql-connector的jar包就可以直接连接mysql，当时就感觉比较奇怪，最后花了一番功夫找到了原因，我在我的C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext目录下找到了这个jar包，原来我并不是没有用这个包，只是我的jar包放在了jre的ext扩展目录，当使用jdk时，他也会被加载。这儿在网上找了一张java类加载器的加载顺序图。7 .使用Maven后遇到了一个错误这是因为idea将项目改为maven项目后，发现jdk默认1.5版本，网上有两种办法解决：①按下面两张图修改②在pom.xml中添加以下内容12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 第一种亲测可行，第二种博主尚未尝试。。。 7 .最后还有一个问题，就是IDEA控制台一直中文乱码，尝试了各种方法都不行，暂且先记下，等以后找到解决方法再说。————————————————补充，上面的控制台中文乱码找到了一种解决方法：到Tomcat根目录下“conf”子目录下的“logging.properties”文件中查看日志记录的配置，找到该文件，可发现很多的“encoding = UTF-8”配置项，将所有的“encoding = UTF-8”都修改为“encoding = GBK”，使其识别支持中文，保存文件修改后，再次启动Tomcat，中文乱码就不见了。 ——————————————————————————————— 六、代码重构一、改为Maven项目由于之前的JavaEE 02项目（也就是学生作业管理系统）已经被我变成Maven了，不太好截图，就随便建了一个项目重新操作了下，顺便截了图 ①右键点击项目名称，点击Add Framework ②选择Maven，点击OK就可以了 ③此外，使用Maven还遇到了一个问题，在上面的总结心得中的第7条列了出来并找到了解决方法。 ④在pom.xml中导入jar包配置联网下载完毕后即可使用jar包我只是用了mysql-connector和fastjson两个jar包，配置如下文件等待自动下载完毕后就可以使用了。 二、关于数据库优化前面的代码里有提到，具体使用了一个静态内部类的单例模式通过getInstance方法去获得获取数据库资源的类实例，然后封装了一个getConnection方法和两个关闭连接的方法。具体代码在第三部分代码设计中的数据库连接类中，代码我就不重复帖了，回过头看一下就可以喽。 最后：github地址： 传送门","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"Java EE - 01","slug":"JavaEE-01","date":"2020-03-04T15:50:39.798Z","updated":"2020-03-05T12:00:36.539Z","comments":true,"path":"2020/03/04/JavaEE-01/","link":"","permalink":"http://yoursite.com/2020/03/04/JavaEE-01/","excerpt":"","text":"一、JAVA(windows)安装教程1.下载java 前往甲骨文官网下载jdk [jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) 这里我下载的是windows版本的jdk8 2.安装 由于之前安装时没有仔细截图，这儿就不贴图片了，当然过程也比较简单，一直点击下一步就行了。 3.环境变量配置（重要） 1.右键我的电脑，点击最下面的属性，之后再弹框里点击高级系统设置，再点击环境变量 2.点击新建后 (1)新建-&gt;变量名&quot;JAVA_HOME&quot;，变量值C:\\Java\\jdk1.8.0_05（即JDK的安装路径） (2)编辑-&gt;变量名&quot;Path&quot;，在原变量值的最后面加上 %JAVA_HOME%\\bin之后一路点击确定 4.验证是否安装成功 1.打卡cmd，输入java -version，出现相关版本信息就ok. 2.打卡cmd, 输入javac，出现javac用法就ok. 二、安装Tomcat (Windows)1.Tomcat下载 1.打开Tomcat官网，默认进入官网首页，官网地址为：[tomcat官网](https://tomcat.apache.org/) 2、左侧的导航栏可以看到 Download（下载），以及最近相关版本的Tomcat（9、8、7...），这里选择的是Tomcat9，点击进入 3、进入tomcat9的相关页面后会显示一些该版本的信息，可以忽略，鼠标下滑进行查找 4、这里我选择了tomcat9 5、现在该选择下载Tomcat9的安装方式了，解压版和安装版，解压版是第一个选项链接，但个人倾向于安装版，即最后一个选项链接（Windows Service Installer - Windows服务的安装程序），点击进行下载 2.Tomcat安装 由于我的电脑8080端口装的apache24，我就把tomcat的配置文件改到了8081端口，因此我当问的是http://localhost:8081/ 1、Tomcat安装还是比较方便的，双击你下载的Tomcat .exe 文件进入安装界面 2、点击 Next（下一步） 3、点击 I Agree（我同意） 4、点击 Next（下一步） 5、到了这里，就需要注意一下了，需要设置自己的端口号（四位），默认为8080，如果你想设置成其他，也可以，但不推荐，因为可能会与其他端口冲突导致Tomcat无法正常启用等后果，想好后点击 Next（下一步） 6、这里就更需要注意了，这是配置jre的关键步骤，所以，在安装Tomcat之前需要下载安装并配置jdk，Tomcat8.5会找到你jre的more默认，如果你在安装jre的时候，为自定义路径，这里就需要改成你的jre安装路径，选择完后点击 Next（下一步） 7、这里就是你Tomcat的默认安装路径，当然，你也可以自定义，看个人喜好，选择完后点击 Install（安装） 8、打开浏览器，输入HTTP协议，加上你的Tomcat的端口号，即 http://localhost:8080/，进入Tomcat页面则表示成功，否则为失败，卸载重装，同时检查你的jdk是否安装配置，安装时jre的路径选择是否正确 三、安装Mysql (Windows)1、安装包下载。 下载地址：下载地址 2、解压缩至安装目录解压缩下载之后的zip，我这里使用的安装路径为：C:\\Program Files\\mysql-8.0.18-winx64 解压缩之后： 1.执行命令：mysqld --initialize-insecure --user=mysql 生成data文件夹 2.配置环境变量 变量名：MYSQL_HOME 变量值：C:\\Program Files\\mysql-8.0.18-winx64 3.编辑-&gt;变量名&quot;Path&quot;，在原变量值的最后面加上 %MYSQL_HOME%\\bin之后一路点击确定 3、 安装MySQL 执行命令：mysqld -install 4、启动服务 执行命令：net start MySQL 5、登录MySQL 登录mysql:(因为之前没设置密码，所以密码为空，不用输入密码，直接回车即可） mysql -u root -p 设置密码：set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); 四、创建IDEA Java EE项目1.打开IDEA，点击Create Project 2.选择Java Enterprise，勾选Web Application 3.新建Tomcat Server 4.编辑项目名称，选择项目位置 5.点击完成 五、使用JDBC连接Mysql，并读取数据1.下载mysql-connector的jar包并复制到项目的lib目录，下载链接：mysql-connector-java.jar下载网址 2.打Project Structer将lib填添加至Libraries 3.编写测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142package com.kle.code;import java.sql.*;public class TestJdbc &#123; public static String getMysql()&#123; String url = \"jdbc:mysql://localhost:3306/school\"; String driverName = \"com.mysql.cj.jdbc.Driver\"; String sqlString = \"SELECT * FROM teacher limit 10\"; try&#123; //加载驱动 Class.forName(driverName); //创建连接 Connection connection = DriverManager.getConnection(url,\"kle\", \"yqyforever\"); //通过连接获取Statement Statement statement = connection.createStatement(); //通过 statement 执行 sqlString 进行查询 ResultSet resultSet = statement.executeQuery(sqlString); while (resultSet.next())&#123; System.out.println(resultSet.getString(1)); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args)&#123; getMysql(); &#125;&#125; 4.运行结果 注意事项：mysql的jdbc驱动名称最新版为“com.mysql.cj.jdbc.Driver”","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"今天学了几个排序算法（一）","slug":"今天学了几个排序算法(一）","date":"2019-04-05T04:32:28.165Z","updated":"2019-04-05T04:51:12.782Z","comments":true,"path":"2019/04/05/今天学了几个排序算法(一）/","link":"","permalink":"http://yoursite.com/2019/04/05/今天学了几个排序算法(一）/","excerpt":"","text":"（本篇实现均为升序）1.冒泡排序 最经典的排序算法。其思想是遍历未排序序列，通过比较相邻元素的值从而实现每次循环后将未排序序列中的最大值（构建升序序列）移至最后，后面的序列就是自动形成的有序序列，之前的序列被看做为排序序列。 算法实现：123456789101112131415161718int* bubble_sort(int arr[], int len)&#123; bool flag = false; for(int i = 0;i &lt; len - 1; i++)&#123; for(int j = 0;j &lt; len - 2 - i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if(!flag)&#123; break; &#125; flag = false; &#125; return arr;&#125; 2.选择排序应该是人们最容易想到的算法，其思想将序列分为有序和未排序两部分，初始的未排序序列就是该序列整体，每次从未排序序列中选取最小的数，与数组前面的元素依次进行交换形成有序序列，直至遍历完毕。算法实现：1234567891011121314int* select_sort(int arr[], int len)&#123; for(int i = 0;i &lt; len - 1;i++)&#123; int min = i; for(int j = i;j &lt; len - 1;j++)&#123; if(arr[j] &lt; arr[min])&#123; min = j; &#125; &#125; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; return arr;&#125; 3.直接插入排序直接插入排序基本的思想是递归，将数组看做一个有序序列和一个无序序列，最开始有序序列只有一个元素arr[0],其余构成无序序列，每次从无序序列中取出一个元素插入有序序列恰当位置，使之成为有序序列，重复n-1次即可完成排序。算法实现：123456789101112int* dire_insert_sort(int arr[], int len)&#123; for(int i = 0;i &lt; len - 1;i++)&#123; int cur = arr[i + 1]; int pre = i; do&#123; arr[pre + 1] = arr[pre]; pre--; &#125;while(temp &lt; arr[j] &amp;&amp; j &gt;= 0); arr[pre + 1] = cur; &#125; return arr;&#125; 4.希尔排序采用了增量减小的排序思想，increment的取值一直有争议，此处increment初始值为len/3取下限+1通过increment构成划分，再对分别划分进行直接插入，直至increment增量小于等于11234567891011121314151617int* shell_sort(int arr[], int len)&#123; do&#123; increment = len / 3 + 1; for(int i = increment;i &lt; len - 1;i++)&#123; if(arr[i - increment] &gt; arr[i])&#123; int temp = arr[i]; int j = i - increment; do&#123; arr[j] = arr[i]; j -= increment; &#125;while(arr[j] &gt; temp &amp;&amp; j &gt;= 0); arr[j + increment] = temp; &#125; &#125; &#125;while(increment &gt; 1); return arr;&#125; 5.归并排序采用了分而治之的思想，将序列看做左右两边，利用递归方法对左右两边排序，最终合并为一个有序序列1234567891011121314151617181920212223242526272829303132333435363738394041424344int* merger_sort(int arr[], int len)&#123; if(len &lt; 2)&#123; return arr; &#125; int middle = len / 2; int* left; int* right; for(int i = 0;i &lt; len - 1;i++)&#123; if(i &lt; middle)&#123; left[i] = arr[i]; &#125;else&#123; right[i - middle] = arr[i]; &#125; &#125; return merge(merger_sort(left, middle), merger_sort(right, len - middle), middle, len - middle);&#125;int *merge(int* left, int* right,int llen, int rlen)&#123; int i = 0; int j = 0; int k = 0; int* result; while(i &lt;= llen - 1 &amp;&amp; j &lt;= rlen - 1)&#123; if(left[i] &lt;= right[j])&#123; result[k] = left[i]; i++; &#125;else&#123; result[k] = right[j]; j++; &#125; k++; &#125; while(i &lt;= llen - 1)&#123; result[k] = left[i]; i++; k++; &#125; while(j &lt; rlen - 1)&#123; result[k] = right[j]; j++; k++; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-23T04:08:14.749Z","updated":"2019-03-23T04:08:14.749Z","comments":true,"path":"2019/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}