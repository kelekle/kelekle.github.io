{"meta":{"title":"Hexo","subtitle":"�չ�һ�䣬�����ƾ�","description":null,"author":"����","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-04T06:13:12.458Z","updated":"2020-03-03T04:23:20.680Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"听风的个人博客","date":"2020-03-04T05:05:18.007Z","updated":"2020-03-04T05:05:18.007Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"这个人比较懒。。。"},{"title":"分类","date":"2020-03-03T04:23:20.701Z","updated":"2020-03-03T04:23:20.701Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-04T05:09:30.639Z","updated":"2020-03-03T04:23:20.710Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-03T04:23:20.705Z","updated":"2020-03-03T04:23:20.705Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-03T04:23:20.714Z","updated":"2020-03-03T04:23:20.714Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-06T07:48:36.869Z","updated":"2020-03-03T04:23:20.696Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""}],"posts":[{"title":"Java EE - 02 做一个作业管理系统（jsp+servlet+layui）","slug":"JAVAEE-02 做一个作业管理系统—jsp+servlet+layui","date":"2020-03-17T02:41:00.529Z","updated":"2020-03-17T02:40:23.594Z","comments":true,"path":"2020/03/17/JAVAEE-02 做一个作业管理系统—jsp+servlet+layui/","link":"","permalink":"http://yoursite.com/2020/03/17/JAVAEE-02 做一个作业管理系统—jsp+servlet+layui/","excerpt":"","text":"JAVAEE-02 做一个作业管理系统（jsp+servlet+layui） 简介技术实现：servlet + jsp + layui + mysql ， 之前学了下layui，所以顺便就用上了，还是蛮好用的哈哈。主要功能：&nbsp; &nbsp;老师：登录，注册，添加自己的新学生、作业（只能面向自己的学生，也可以是部分学生），查看自己的学生、自己布置的作业以及学生作业的完成情况，删除学生、作业，更改学生信息，更改作业信息，登出&nbsp; &nbsp;学生：登录，查看作业、提交作业，登出 一、数据库设计 数据库一共有五张表,设计均满足第三范式要求: student(sid)&nbsp; &nbsp; teacher(tid)&nbsp;&nbsp; homework(hid)&nbsp; &nbsp; student_homework(sid, hid) teach(sid, tid) 数据库连接类采用了单例模式，在第三部分代码设计会讲到。 以下是数据库关系模式图 二、业务流程 学生流程图 老师的流程图 三、代码设计 采用了前端cookie保持登录状态，当再次打开登录页面时，会进行登录状态的判断，若已登录且未退出，则会自动进行登录，登录成功与登出成功的时候则会改变cookie中的登录状态。 添加了拦截器设置，用来检验登录状态，未登录时不能访问只有登录后才能访问的页面，除了index.jsp(欢迎页面，在这个页面里我直接跳转到了登录页面)、login.jsp、register.jsp registerSuccess.jsp、/studentLogin、/teacherLogin(需要登录验证的几个)页面外，属于老师的设置了拦截器TeacherLoginFliter，属于学生的设置了StudentLoginFilter。代码比较多，我在这贴一些主要的代码就行，剩下的我就不一一赘述，大家可以在我的的github去看&nbsp;&nbsp;仓库地址下面是StudentLoginFilter，TeacherLoginFilter也是类似的，在这就不贴了1234567891011121314151617181920212223242526272829303132public class StudentLoginFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(\"utf-8\"); //防止中文乱码 HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; Cookie[] cookies = request.getCookies(); String loginStatus = \"\"; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; filterChain.doFilter(servletRequest, servletResponse); return; &#125; break; &#125; &#125; response.sendRedirect(\"login.jsp\"); &#125; @Override public void destroy() &#123; &#125;&#125; web.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;StudentLoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kle.code.filter.StudentLoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 配置多个映射，哪些请求执行过滤器 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;StudentLoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/student/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;TeacherLoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.kle.code.filter.TeacherLoginFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;TeacherLoginFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/teacher/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; login.jsp进行登录判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;% request.setCharacterEncoding(\"utf-8\"); //防止中文乱码 Cookie[] cookies = request.getCookies(); boolean studentLogged = false; boolean teacherLogged = false; String username = \"\"; String password = \"\"; if(cookies != null)&#123; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/student/studentHome\"); &#125; else if (\"teacher_true\".equals(loginStatus)) &#123; response.sendRedirect(\"/teacher/teacherHome\"); &#125; break; &#125; &#125; for (Cookie c : cookies) &#123; if (\"loginStatus\".equals(c.getName())) &#123; String loginStatus = c.getValue(); if (\"student_false\".equals(loginStatus)) &#123; studentLogged = true; &#125; else if (\"teacher_false\".equals(loginStatus)) &#123; teacherLogged = true; &#125; break; &#125; &#125; if(teacherLogged || studentLogged)&#123; //输入框显示账号密码 for(Cookie c : cookies)&#123; if(\"username\".equals(c.getName()))&#123; username = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; if(\"password\".equals(c.getName()))&#123; password = URLDecoder.decode(c.getValue(), \"utf-8\"); &#125; &#125; &#125; &#125;%&gt;//刚开始显示的是学生登录页面&lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; studentLogged)&#123; %&gt;&lt;script&gt; document.getElementById(\"s_username\").value = &lt;%=username%&gt;; document.getElementById(\"s_password\").value = &lt;%=password%&gt;;&lt;/script&gt;&lt;%&#125;%&gt;&lt;/body&gt;&lt;script src=\"static/layui/layui.all.js\"&gt;&lt;/script&gt;&lt;script&gt; layui.use('element', function()&#123; var element = layui.element; //学生、老师登录页面切换监听 element.on('tab(demo)', function(data)&#123; //切换到学生页面 if(data.index === 0)&#123; &lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; studentLogged)&#123; %&gt; document.getElementById(\"s_username\").value = &lt;%=username%&gt;; document.getElementById(\"s_password\").value = &lt;%=password%&gt;; &lt;%&#125;%&gt; &#125;else &#123; //切换到老师页面 &lt;% if(!username.equals(\"\") &amp;&amp; !password.equals(\"\") &amp;&amp; teacherLogged)&#123; %&gt; document.getElementById(\"t_username\").value = &lt;%=username%&gt;; document.getElementById(\"t_password\").value = &lt;%=password%&gt;; &lt;%&#125;%&gt; &#125; &lt;%&#125;%&gt; &#125;); &#125;);&lt;/script&gt; 数据库连接类 采用单例模式实现数据库连接资源获取类，在这我是用的是静态内部类的方式，利用了jvm的加载机制，当然也可以用DCL的方式实现，这两种都是比较推荐的实现方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class DbUtil &#123; private String url = \"jdbc:mysql://127.0.0.1:3306/class\"; private String allUrl = url + \"?user=kle&amp;password=yqyforever\"; public Connection getConnection()&#123; Connection conn = null; try &#123; String driverName = \"com.mysql.cj.jdbc.Driver\"; Class.forName(driverName); conn = DriverManager.getConnection(allUrl); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; /** * 关闭数据库连接 * @param rs * @param conn * @param stat */ public void close(Connection conn,Statement stat, ResultSet rs)&#123; if(rs != null)&#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; rs = null; &#125; &#125; if(stat != null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; stat = null; &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; conn = null; &#125; &#125; &#125; /** * 关闭数据库连接 * @param conn * @param stat */ public void close(Connection conn,Statement stat)&#123; if(stat != null)&#123; try &#123; stat.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; stat = null; &#125; &#125; if(conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally&#123; conn = null; &#125; &#125; &#125; //静态内部类-单例模式 获取数据库资源连接类 private static class SingleHolder&#123; private static DbUtil INSTANCE = new DbUtil(); &#125; public static DbUtil getInstance()&#123; return SingleHolder.INSTANCE; &#125;&#125; DbUtil的使用 1234567891011121314151617181920212223242526public List&lt;Homework&gt; getHomeworkOfTeacher(String tid) &#123; String sqlString = \"SELECT * FROM homework WHERE tid=\" + tid; List&lt;Homework&gt; list = new ArrayList&lt;&gt;(); //获取连接 Connection connection = DbUtil.getInstance().getConnection(); ResultSet resultSet = null; try&#123; Statement statement = connection.createStatement(); resultSet = statement.executeQuery(sqlString); while (resultSet.next())&#123; Homework h = new Homework(); h.setHid(resultSet.getInt(\"hid\")); h.setTitle(resultSet.getString(\"title\")); h.setContent(resultSet.getString(\"content\")); h.setCreateTime(resultSet.getTimestamp(\"create_time\")); h.setUpdateTime(resultSet.getTimestamp(\"update_time\")); list.add(h); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭连接 DbUtil.getInstance().close(resultSet); &#125; return list; &#125; 四、页面展示注册、登录老师：学生： 五、总结心得1 . jar包的添加 不使用构建工具，这里以我使用的阿里的fastjson为例： ①File-&gt;Project Structure-&gt;Modules-&gt;Dependencies，添加jar包 ②Artifacts, 右键点击WEB-INF，创建lib文件夹，这儿有个注意的点：创建完成后在IDEA里是看不到这个文件夹的，只有在out文件夹下才能找到，所以没有找到的画不用太担心，属于正常现象 ③在右边项目里找到要添加的模块，右键点击Put into /WEB-INF/lib ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312230431469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDQ2ODUy,size_16,color_FFFFFF,t_70) ④最后点击ok就大功告成了 2 . WEB-INF属于安全目录，其下的文件是不能直接通过地址栏访问的 以下是几种访问WEB-INF下文件的方式 方法一:本来WEB-INF中的jsp就是无法通过地址栏访问的，所以安全。如果说你要访问这个文件夹中的jsp文件需要在项目的web.xml文件中去配置servlet格式差不多的配置就ok了方法二 &lt;jsp:forward page = “/WEB-INF/jsp/test/test.jsp” /&gt;方法三 request.getRequestDispatcher(“/WEB-INF/a.jsp”).forward(request, response); 3 . 关于数据库的单例模式我采用的是静态内部类，利用了jvm的类加载机制，当然推荐的还有DCL实现，当然还有其他的实现方式，不过大都有点缺陷，不是特别推荐使用。使用单例模式的原因：数据库链接用单例模式的原因：1，单例只保留一个对象，可以减少系统资源开销。2，提高创建速度，每次都获取已经存在的对象因此提高创建速度全局共享对象。3，单例在系统中只存在一个对象实例，因此任何地方使用此对象都是一个对象避免多实例创建使用时产生的逻辑错误。 这儿给大家推荐一篇博客，讲了单例模式的各种实现方式以及优缺点，大家可以看一下，讲的还是挺拔不错的，比较简洁单例模式实现博客链接静态内部类前面写过了，这儿说一下DCL，写的时候一定要在INSTANCE前加上volatile,避免jvm编译器的指令重排会导致并发问题 1234567891011121314public class Singleton &#123; private static volatile Singleton instance = null; private Singleton()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 4 .关于jsp接收到servlet返回数据的中文乱码 对请求以及响应进行编码设置即可12req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); 5 .Servlet向前端返回json等数据 123456String jsonString = \"[]\"; //获取response的Writer对象，用来写入返回数据 PrintWriter out = resp.getWriter(); out.write(jsonString); out.flush(); out.close(); 6 .之前在我的电脑发现了一个现象，我的电脑似乎不用导入mysql-connector的jar包就可以直接连接mysql，当时就感觉比较奇怪，最后花了一番功夫找到了原因，我在我的C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext目录下找到了这个jar包，原来我并不是没有用这个包，只是我的jar包放在了jre的ext扩展目录，当使用jdk时，他也会被加载。这儿在网上找了一张java类加载器的加载顺序图。7 .使用Maven后遇到了一个错误这是因为idea将项目改为maven项目后，发现jdk默认1.5版本，网上有两种办法解决：①按下面两张图修改②在pom.xml中添加以下内容12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 第一种亲测可行，第二种博主尚未尝试。。。 7 .最后还有一个问题，就是IDEA控制台一直中文乱码，尝试了各种方法都不行，暂且先记下，等以后找到解决方法再说。————————————————补充，上面的控制台中文乱码找到了一种解决方法：到Tomcat根目录下“conf”子目录下的“logging.properties”文件中查看日志记录的配置，找到该文件，可发现很多的“encoding = UTF-8”配置项，将所有的“encoding = UTF-8”都修改为“encoding = GBK”，使其识别支持中文，保存文件修改后，再次启动Tomcat，中文乱码就不见了。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"},{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"Java EE - 01","slug":"JavaEE-01","date":"2020-03-04T15:50:39.798Z","updated":"2020-03-05T12:00:36.539Z","comments":true,"path":"2020/03/04/JavaEE-01/","link":"","permalink":"http://yoursite.com/2020/03/04/JavaEE-01/","excerpt":"","text":"一、JAVA(windows)安装教程1.下载java 前往甲骨文官网下载jdk [jdk下载地址](https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html) 这里我下载的是windows版本的jdk8 2.安装 由于之前安装时没有仔细截图，这儿就不贴图片了，当然过程也比较简单，一直点击下一步就行了。 3.环境变量配置（重要） 1.右键我的电脑，点击最下面的属性，之后再弹框里点击高级系统设置，再点击环境变量 2.点击新建后 (1)新建-&gt;变量名&quot;JAVA_HOME&quot;，变量值C:\\Java\\jdk1.8.0_05（即JDK的安装路径） (2)编辑-&gt;变量名&quot;Path&quot;，在原变量值的最后面加上 %JAVA_HOME%\\bin之后一路点击确定 4.验证是否安装成功 1.打卡cmd，输入java -version，出现相关版本信息就ok. 2.打卡cmd, 输入javac，出现javac用法就ok. 二、安装Tomcat (Windows)1.Tomcat下载 1.打开Tomcat官网，默认进入官网首页，官网地址为：[tomcat官网](https://tomcat.apache.org/) 2、左侧的导航栏可以看到 Download（下载），以及最近相关版本的Tomcat（9、8、7...），这里选择的是Tomcat9，点击进入 3、进入tomcat9的相关页面后会显示一些该版本的信息，可以忽略，鼠标下滑进行查找 4、这里我选择了tomcat9 5、现在该选择下载Tomcat9的安装方式了，解压版和安装版，解压版是第一个选项链接，但个人倾向于安装版，即最后一个选项链接（Windows Service Installer - Windows服务的安装程序），点击进行下载 2.Tomcat安装 由于我的电脑8080端口装的apache24，我就把tomcat的配置文件改到了8081端口，因此我当问的是http://localhost:8081/ 1、Tomcat安装还是比较方便的，双击你下载的Tomcat .exe 文件进入安装界面 2、点击 Next（下一步） 3、点击 I Agree（我同意） 4、点击 Next（下一步） 5、到了这里，就需要注意一下了，需要设置自己的端口号（四位），默认为8080，如果你想设置成其他，也可以，但不推荐，因为可能会与其他端口冲突导致Tomcat无法正常启用等后果，想好后点击 Next（下一步） 6、这里就更需要注意了，这是配置jre的关键步骤，所以，在安装Tomcat之前需要下载安装并配置jdk，Tomcat8.5会找到你jre的more默认，如果你在安装jre的时候，为自定义路径，这里就需要改成你的jre安装路径，选择完后点击 Next（下一步） 7、这里就是你Tomcat的默认安装路径，当然，你也可以自定义，看个人喜好，选择完后点击 Install（安装） 8、打开浏览器，输入HTTP协议，加上你的Tomcat的端口号，即 http://localhost:8080/，进入Tomcat页面则表示成功，否则为失败，卸载重装，同时检查你的jdk是否安装配置，安装时jre的路径选择是否正确 三、安装Mysql (Windows)1、安装包下载。 下载地址：下载地址 2、解压缩至安装目录解压缩下载之后的zip，我这里使用的安装路径为：C:\\Program Files\\mysql-8.0.18-winx64 解压缩之后： 1.执行命令：mysqld --initialize-insecure --user=mysql 生成data文件夹 2.配置环境变量 变量名：MYSQL_HOME 变量值：C:\\Program Files\\mysql-8.0.18-winx64 3.编辑-&gt;变量名&quot;Path&quot;，在原变量值的最后面加上 %MYSQL_HOME%\\bin之后一路点击确定 3、 安装MySQL 执行命令：mysqld -install 4、启动服务 执行命令：net start MySQL 5、登录MySQL 登录mysql:(因为之前没设置密码，所以密码为空，不用输入密码，直接回车即可） mysql -u root -p 设置密码：set password for &apos;root&apos;@&apos;localhost&apos; = password(&apos;123456&apos;); 四、创建IDEA Java EE项目1.打开IDEA，点击Create Project 2.选择Java Enterprise，勾选Web Application 3.新建Tomcat Server 4.编辑项目名称，选择项目位置 5.点击完成 五、使用JDBC连接Mysql，并读取数据1.下载mysql-connector的jar包并复制到项目的lib目录，下载链接：mysql-connector-java.jar下载网址 2.打Project Structer将lib填添加至Libraries 3.编写测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142package com.kle.code;import java.sql.*;public class TestJdbc &#123; public static String getMysql()&#123; String url = \"jdbc:mysql://localhost:3306/school\"; String driverName = \"com.mysql.cj.jdbc.Driver\"; String sqlString = \"SELECT * FROM teacher limit 10\"; try&#123; //加载驱动 Class.forName(driverName); //创建连接 Connection connection = DriverManager.getConnection(url,\"kle\", \"yqyforever\"); //通过连接获取Statement Statement statement = connection.createStatement(); //通过 statement 执行 sqlString 进行查询 ResultSet resultSet = statement.executeQuery(sqlString); while (resultSet.next())&#123; System.out.println(resultSet.getString(1)); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String[] args)&#123; getMysql(); &#125;&#125; 4.运行结果 注意事项：mysql的jdbc驱动名称最新版为“com.mysql.cj.jdbc.Driver”","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"今天学了几个排序算法（一）","slug":"今天学了几个排序算法(一）","date":"2019-04-05T04:32:28.165Z","updated":"2019-04-05T04:51:12.782Z","comments":true,"path":"2019/04/05/今天学了几个排序算法(一）/","link":"","permalink":"http://yoursite.com/2019/04/05/今天学了几个排序算法(一）/","excerpt":"","text":"（本篇实现均为升序）1.冒泡排序 最经典的排序算法。其思想是遍历未排序序列，通过比较相邻元素的值从而实现每次循环后将未排序序列中的最大值（构建升序序列）移至最后，后面的序列就是自动形成的有序序列，之前的序列被看做为排序序列。 算法实现：123456789101112131415161718int* bubble_sort(int arr[], int len)&#123; bool flag = false; for(int i = 0;i &lt; len - 1; i++)&#123; for(int j = 0;j &lt; len - 2 - i;j++)&#123; if(arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = true; &#125; &#125; if(!flag)&#123; break; &#125; flag = false; &#125; return arr;&#125; 2.选择排序应该是人们最容易想到的算法，其思想将序列分为有序和未排序两部分，初始的未排序序列就是该序列整体，每次从未排序序列中选取最小的数，与数组前面的元素依次进行交换形成有序序列，直至遍历完毕。算法实现：1234567891011121314int* select_sort(int arr[], int len)&#123; for(int i = 0;i &lt; len - 1;i++)&#123; int min = i; for(int j = i;j &lt; len - 1;j++)&#123; if(arr[j] &lt; arr[min])&#123; min = j; &#125; &#125; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; return arr;&#125; 3.直接插入排序直接插入排序基本的思想是递归，将数组看做一个有序序列和一个无序序列，最开始有序序列只有一个元素arr[0],其余构成无序序列，每次从无序序列中取出一个元素插入有序序列恰当位置，使之成为有序序列，重复n-1次即可完成排序。算法实现：123456789101112int* dire_insert_sort(int arr[], int len)&#123; for(int i = 0;i &lt; len - 1;i++)&#123; int cur = arr[i + 1]; int pre = i; do&#123; arr[pre + 1] = arr[pre]; pre--; &#125;while(temp &lt; arr[j] &amp;&amp; j &gt;= 0); arr[pre + 1] = cur; &#125; return arr;&#125; 4.希尔排序采用了增量减小的排序思想，increment的取值一直有争议，此处increment初始值为len/3取下限+1通过increment构成划分，再对分别划分进行直接插入，直至increment增量小于等于11234567891011121314151617int* shell_sort(int arr[], int len)&#123; do&#123; increment = len / 3 + 1; for(int i = increment;i &lt; len - 1;i++)&#123; if(arr[i - increment] &gt; arr[i])&#123; int temp = arr[i]; int j = i - increment; do&#123; arr[j] = arr[i]; j -= increment; &#125;while(arr[j] &gt; temp &amp;&amp; j &gt;= 0); arr[j + increment] = temp; &#125; &#125; &#125;while(increment &gt; 1); return arr;&#125; 5.归并排序采用了分而治之的思想，将序列看做左右两边，利用递归方法对左右两边排序，最终合并为一个有序序列1234567891011121314151617181920212223242526272829303132333435363738394041424344int* merger_sort(int arr[], int len)&#123; if(len &lt; 2)&#123; return arr; &#125; int middle = len / 2; int* left; int* right; for(int i = 0;i &lt; len - 1;i++)&#123; if(i &lt; middle)&#123; left[i] = arr[i]; &#125;else&#123; right[i - middle] = arr[i]; &#125; &#125; return merge(merger_sort(left, middle), merger_sort(right, len - middle), middle, len - middle);&#125;int *merge(int* left, int* right,int llen, int rlen)&#123; int i = 0; int j = 0; int k = 0; int* result; while(i &lt;= llen - 1 &amp;&amp; j &lt;= rlen - 1)&#123; if(left[i] &lt;= right[j])&#123; result[k] = left[i]; i++; &#125;else&#123; result[k] = right[j]; j++; &#125; k++; &#125; while(i &lt;= llen - 1)&#123; result[k] = left[i]; i++; k++; &#125; while(j &lt; rlen - 1)&#123; result[k] = right[j]; j++; k++; &#125; return result;&#125;","categories":[],"tags":[]},{"title":"hello","slug":"hello","date":"2019-03-23T04:45:01.000Z","updated":"2019-04-05T04:36:59.124Z","comments":true,"path":"2019/03/23/hello/","link":"","permalink":"http://yoursite.com/2019/03/23/hello/","excerpt":"","text":"###this is my first blog written by hexo###","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-23T04:08:14.749Z","updated":"2019-03-23T04:08:14.749Z","comments":true,"path":"2019/03/23/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}